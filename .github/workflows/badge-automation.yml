name: Registrar Badges e Criar Certificados

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write

jobs:
  process-badge:
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üß∞ Instalar Node
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: üß† Identificar tipo de badge pelo t√≠tulo do PR
        id: badge-detector
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          echo "T√≠tulo detectado: $TITLE"

          if [[ "$TITLE" == *"[mestre]"* ]]; then
            echo "badge_type=mestre" >> $GITHUB_OUTPUT
          elif [[ "$TITLE" == *"[apoia]"* ]]; then
            echo "badge_type=apoia" >> $GITHUB_OUTPUT
          else
            echo "‚ùå ERRO: O PR precisa conter [mestre] ou [apoia] no t√≠tulo."
            exit 1
          fi

      - name: üìù Criar script de automa√ß√£o
        run: |
          mkdir -p badges certificados templates

          # Templates (se preferir, coloque esses arquivos diretamente no reposit√≥rio para evitar indenta√ß√£o)
          if [ ! -f "templates/MestreDaDocumentacao.md" ]; then
cat > templates/MestreDaDocumentacao.md <<'TEMPLATE'
# Certificado Mestre da Documenta√ß√£o

**Usu√°rio:** {{githubUser}}
**Nome:** {{name}}
**Reposit√≥rio:** {{repository}}
**Data:** {{date}}

Parab√©ns por contribuir com a documenta√ß√£o!
TEMPLATE
          fi

          if [ ! -f "templates/DevApoiaDev.md" ]; then
cat > templates/DevApoiaDev.md <<'TEMPLATE'
# Certificado Dev que Apoia Dev

**Usu√°rio:** {{githubUser}}
**Nome:** {{name}}
**Reposit√≥rio:** {{repository}}
**Data:** {{date}}

Obrigado por apoiar outros desenvolvedores!
TEMPLATE
          fi

          cat > process.js <<'EOF'
const fs = require('fs');

function ensureDirectories() {
  const dirs = ['badges', 'certificados', 'templates'];
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
}

function loadBadges() {
  try {
    if (fs.existsSync('badges.json')) {
      const raw = fs.readFileSync('badges.json', 'utf8').trim();
      if (raw) {
        return JSON.parse(raw);
      }
    }
  } catch (err) {
    console.log('Erro ao ler badges.json, criando novo:', err.message);
  }

  const defaultData = {
    mestreDaDocumentacao: [],
    devApoiaDev: []
  };
  fs.writeFileSync('badges.json', JSON.stringify(defaultData, null, 2));
  return defaultData;
}

function sanitizeName(name) {
  if (!name) return 'unknown';
  return name.replace(/[^a-z0-9_.-]/gi, '-').toLowerCase();
}

function main() {
  ensureDirectories();

  const badgeType = process.env.BADGE_TYPE;
  const githubUserRaw = process.env.PR_USER;
  const repository = process.env.REPO_URL || '';
  const githubUser = sanitizeName(githubUserRaw);
  const name = githubUserRaw || githubUser;
  const date = new Date().toISOString().split('T')[0];

  if (!badgeType) {
    console.error('BADGE_TYPE n√£o definido. Abortando.');
    process.exit(1);
  }

  console.log(`Processando badge: ${badgeType} para ${githubUserRaw} (sanitizado: ${githubUser})`);

  const badges = loadBadges();

  const badgeList = badgeType === "mestre" ? badges.mestreDaDocumentacao : badges.devApoiaDev;
  const alreadyHasBadge = badgeList.some(entry => entry.githubUser === githubUser);

  if (!alreadyHasBadge) {
    const entry = { githubUser, name, repository, date };
    if (badgeType === "mestre") {
      badges.mestreDaDocumentacao.push(entry);
    } else {
      badges.devApoiaDev.push(entry);
    }
    fs.writeFileSync('badges.json', JSON.stringify(badges, null, 2));
    console.log('Badge registrado com sucesso!');
  } else {
    console.log('Usu√°rio j√° possui este badge');
  }

  const badgeLabel = badgeType === "mestre" ? "Mestre da Documenta√ß√£o" : "Dev que Apoia Dev";

  const svgContent =
    '<svg width="420" height="100" xmlns="http://www.w3.org/2000/svg">' +
    '<rect width="420" height="100" fill="#1e1e1e" rx="12"></rect>' +
    '<text x="210" y="55" font-size="20" fill="white" font-family="Arial, sans-serif" text-anchor="middle" alignment-baseline="middle">' +
    badgeLabel +
    '</text></svg>';

  const svgFilename = `badges/${githubUser}-${badgeType}.svg`;
  fs.writeFileSync(svgFilename, svgContent);
  console.log(`Badge SVG criado: ${svgFilename}`);

  const tplPath = badgeType === "mestre" ? "templates/MestreDaDocumentacao.md" : "templates/DevApoiaDev.md";

  if (fs.existsSync(tplPath)) {
    let template = fs.readFileSync(tplPath, "utf8");

    template = template
      .replace(/{{githubUser}}/g, githubUserRaw || githubUser)
      .replace(/{{name}}/g, name)
      .replace(/{{repository}}/g, repository)
      .replace(/{{date}}/g, date);

    const certFilename = `certificados/${githubUser}-${badgeType === "mestre" ? 'MestreDaDocumentacao' : 'DevApoiaDev'}.md`;

    fs.writeFileSync(certFilename, template);
    console.log(`Certificado criado: ${certFilename}`);
  } else {
    console.warn(`Template n√£o encontrado: ${tplPath}`);
  }
}

main();
EOF

      - name: üöÄ Executar automa√ß√£o
        env:
          PR_USER: ${{ github.actor }}
          BADGE_TYPE: ${{ steps.badge-detector.outputs.badge_type }}
          REPO_URL: ${{ github.event.repository.html_url }}
        run: node process.js

      - name: üíæ Commit autom√°tico
        id: commit-changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Adicionar altera√ß√µes
          git add -A

          # Se n√£o houver mudan√ßas, sair
          if git diff --staged --quiet; then
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Nenhuma altera√ß√£o para commitar"
            exit 0
          fi

          git commit -m "üéâ Badge e certificado criados para ${{ github.actor }} [skip ci]" || echo "Sem mudan√ßas para commitar"
          # Tentar push; se falhar, mostrar instru√ß√£o (ex.: PR de fork pode impedir push)
          if git push; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Altera√ß√µes commitadas e pushedas"
          else
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "::warning::Falha ao dar push. Se este PR for de um fork, o workflow n√£o tem permiss√£o para push na branch do fork."
            exit 0
          fi

      - name: üîÅ AutoMerge PR (Opcional)
        if: steps.commit-changes.outputs.changes == 'true'
        uses: pascalgn/automerge-action@v0.16.3
        with:
          merge-method: squash
          pull-request-filter: "labeled:automerge"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}